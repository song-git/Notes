字符设备驱动：
scull：以一块内存代替物理设备，实现一个字符驱动。
只是用来演示内核提供的字符设备框架如何使用。
===============================================================================
scull的设计：
编写驱动的第一步是设计该驱动将要为应用程序提供什么样的功能。

由于我们使用的是一块内存来替代真实的设备，所以我们可以很自由的使用它，可以进行顺序或者随机的访问，
也可以将它设计成一个或多个设备。
为了让scull成为一个真实设备驱动的有用的模板。我们将在内存中模拟多个设备，它们拥有不同的职责。

scull实现以下几种设备（驱动），模块根据每种设备的type属性来执行它们的代码。
scull0 - scull3：
	这是4个设备（驱动），都由一块内存组成， 它们具有整体性以及固有性。
整体性体现在，如果设备被多次打开，所有操作它的文件指针将共享设备上的数据。
固有性体现在，如果设备被关闭然后再重新打开，数据不会丢失。
这些设备是很有趣的，因为它们可以使用传统的命令行来进行测试，例如cat、cp以及IO重定向。
scullpipe0 - scullpipe3：
	四个FIFO设备，类似于管道，一个程序读一个程序写。
在scullpipe内部将演示如何实现不使用中断的阻塞与非阻塞式的读写。
虽然真实的设备驱动使用硬件中断来进行同步，但是阻塞与非阻塞是一个重要的、独立的、与中断无关的主题。
scullsingle：
scullpriv：
sculluid：
scullwuid：
	这些设备（驱动）类似于scull0，但是对于open有一些限制。
scullsingle：同一时刻只允许一个程序访问。
scullpriv：对于每个虚拟终端是私有的，因为每个终端中的进程在访问它时会访问不同的内存区域。
sculluid，scullwuid：可以被多次打开，但同一时刻只能被同一用户打开。如果已经有其他用户打开（锁）而不同的用户试图
再打开它的话，sculluid会返回一个“Device busy”的错误。而scullwuid的实现是阻塞那个打开操作。

这些不同的scull展示了驱动中不同的特性，这一章只实现scull0 - scull3。

===============================================================================
主版本号（major）与次版本号（minor）：

字符设备是通过文件系统中的一个名字（文件名）来访问的。它们被称为特殊文件、设备文件或者node。这些文件一般位于/dev目录。
通过ls -l 命令可以看到这些文件前面的c（字符设备）或者b（块设备）等标识。
同时在ls -l 后还可以看到两个以逗号分割的数字（在‘修改日期’字段之前，一般的文件这个位置显示的是文件大小）。
传统的，主版本号用来识别设备，比如所有的虚拟终端都是4。
现在的Linux内核支持多个驱动共享一个主版本号，但是大多数的设备还是遵循一个驱动一个主版本号的原则。

内核使用次版本号来精确定位到某个具体关联的设备。
===============================================================================
设备号（Device Number）的内部表示：
在内核中，设备号用一个dev_t的类型来表示（定义在linux/types.h）
在2.6内核中，dev_t是一个32位的数据，其中12位表示主版本号，20位表示次版本号。
你的程序不应该假设内核中的版本号是如何表示的，相反，应该使用一系列的宏从dev_t中获取版本号。这些宏定义在linux/kdev_t.h
MAJOR(dev_t dev);
MINOR(dev_t dev);
相反，也可以使用主版本号和次版本号来计算dev_t
MKDEV(int major,int minor);

===============================================================================
分配与释放设备号：
驱动需要做的第一件事就是获得一个或多个可以使用的设备号。
register_chrdev_region(dev_t first,unsigned int count,char *name);函数可以用来完成这个任务。
在这里，first是你想要分配的第一个设备号。count是需要分配的个数，name是名称，出现在/proc/devices等地方。
要注意的是如果count很大的话可能会导致分配到下一个主版本号。但也能正常工作，只要count在规定范围内。
这个函数执行成功将返回0，出错则返回一个负数，且不能去访问申请失败的对象。

上面的函数在你知道你应该使用哪个主设备号的情况下可以工作得很好，但大多时候可能你不知道你应该使用哪些设备号。
基于此内核很乐意为你动态的分配一个设备号，不过你需要使用另一个函数来请求这样的动态分配：
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor,unsigned int count, char *name);
这个函数的dev参数是一个出参。在分配成功后它保存的是第一个设备号。
firstminor表示想要分配的第一个次版本号，其他两个参数跟上面的一样。

无论如何分配版本号，在最后不需要使用时均需要释放，使用：
void unregister_chrdev_region(dev_t first, unsigned int count);
一般在模块的清理函数中调用它。

动态分配主版本号：

一些主版本号已经静态的分配给一些常用设备。 详情可查看 Documentation/devices.txt

===============================================================================
重要的数据结构：

注册设备号仅仅是驱动必须完成的第一步。
大部分驱动的基本操作包含三个重要的内核数据结构。它们是file_operations、file、inode

一、file_operations：
将设备的操作与设备号绑定起来。这个结构定义在<linux/fs.h>
它是一个函数指针的集合。每一个打开的文件（内部表示为一个file结构）都会关联一个file_operations结构的对象（f_op成员）。
成员：
struct module *owner 表示拥有这个结构的模块，用于防止在还在操作时卸载模块，
一般简单初始化为THIS_MODULE（linux/module.h）

二、file结构体：
定义在linux/fs.h，是内核定义的，与C库中定义的FILE不是一个东西。file结构体表示一个打开的文件。
它不是驱动专用的，系统中每一个打开的文件都关联了一个file结构体。
当调用open打开一个文件时，内核会创建一个file结构体，它会被传递给每一个需要操作这个文件的（驱动）函数。
当所有的引用都调用close时，内核释放它。
其中的成员 void *private_data 可以自定义使用，最适合用来引用一些分配的空间或者状态。

三、inode结构体
内核使用这个结构体来表示一个文件。与file表示一个打开的文件不一样。
同一个文件可以被多个file结构体所表示（不同的打开状态）。但它们都指向同一个inode。
inode结构体包含了与文件相关的大量的信息，但对于驱动开发者而言，只需要关注其中的两个：
dev_t i_rdev;
对于设备文件而言，这个字段包含的是设备号。
同时，内核提供两个宏来通过inode获取主次设备号。
unsigned int iminor(struct inode *inode);
unsigned int imajor(struct inode *inode);

struct cdev *i_cdev;
cdev结构体是内核用来表示一个字符设备的结构体。

===============================================================================
字符设备的注册：
由于内核使用cdev来表示一个字符设备，因此要使用设备相关的操作，必须先为一个或多个cdev分配空间并将它们注册到内核中。
cdev及其相关函数定义在linux/cdev.h中。
为cdev分配空间及初始化有两种方式：
1、在运行时分配：
struct cdev *my_cdev = cdev_alloc( );
my_cdev->ops = &my_fops;
2、一般，我们将cdev封装成一个特定设备的结构体，并且已经为这个结构体分配了空间，这样的话，我们可以通过以下函数初始化它
void cdev_init(struct cdev *cdev, struct file_operations *fops);
与file_operations类似，cdev结构中也有一个owner成员，需要初始化为THIS_MODULE。

最后一步就是将创建好的cdev告知内核，使用以下函数：
int cdev_add(struct cdev *dev, dev_t num, unsigned int count);
在使用cdev_add时需要考虑以下几个问题：
1、这个函数可能失败，并返回一个负数。
2、一旦这个函数调用成功，设备对于内核来说就可见了，内核可以调用它的操作。所以在调用cdev_add之前必须确保一切准备已经就绪。

总结一下，具体的操作就是：
1、申请版本号
2、创建cdev结构体（分配空间与初始化）
3、创建file_operations对象并关联操作
4、注册设备


===============================================================================
open函数要做的：
1、检查设备的状态是否可用
2、如果是第一次打开的话则初始化设备配置
3、如果必要的话更新f_op指针（file结构体的成员）
4、初始化并填充file的private_data成员。

release函数要做的：
1、释放open分配的一切资源。
2、如果是最后一个被调用的close的话则关闭设备。
不是所有的close系统调用都会导致release被调用。只有真正要释放资源的close才会引起release被调用。
内核使用一个计数来统计一个文件被使用多少次，fork和dup等系统调用均不会创建新的file结构体，它们
只是对已经存在的file的计数加1。只有当计数减少到0时close系统调用才会调用release函数。

注意：当调用close时，均会调用flush函数。只有很少一部分驱动会实现flush函数。
系统在一个进程结束时会对其打开的所有文件调用close系统调用。

===============================================================================
Linux内核的内存管理函数：
void *kmalloc(size_t size, int flags);
void kfree(void *ptr);
定义在<linux/slab.h>中。
对于分配大块内存来说kmalloc不是最有效的。

scull的每一个设备都是由指针组成的链表。每一个指针指向一个scull_dev结构体（封装了cdev）。


内核与用户层数据传输：
<asm/uaccess.h>
unsigned long copy_to_user(void __user *to,const void *from,unsigned long count);
unsigned long copy_from_user(void *to,const void __user *from,unsigned long count);
在使用这些函数时需要额外注意：用户数据可能不在内存中，因此系统会挂起当前进程（处理缺页中断）。
因此使用这些函数的地方必须是可重入的且要注意与其他驱动的同步。

这些函数不仅仅可以用来拷贝数据，还可以用来检测用户层的指针是否有效。

无论传输了多少数据，在read和write调用成功后都需要通过offp来修改当前文件位置。

===============================================================================
某些Unix系统还提供了readv和writev等系统调用，驱动中可以支持它们。
...








