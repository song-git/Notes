CHAPTER 2: Building and running modules
===============================================================================
函数：module_init , module_exit 加载/卸载模块时调用的函数
宏    : MODULE_LICENSE("Dule BSD/GPL")

printk函数是在内核中定义的，在模块中可以使用。它的用法和标准C库中的printf函数一样。
内核需要自己的打印函数是因为内核自身单独的运行，没有C库。模块中可以使用printk是因为
在使用insmod加载模块以后，模块会被链接到内核中，因此它可以访问内核中定义的公共的符号
。字符串KERN_ALERT是需要打印的消息的优先级。在模块中我们为打印消息定义了比较高的优先级
这是因为默认的优先级不会正确的打印出来。

内核模块与应用程序：
再进行下一步之前，我们有必要了解内核模块与应用程序之间的许多不同之处。

大多数的应用程序表现为一个从开始到结束的任务，内核模块与之不同。
内核模块仅仅是将自己注册到系统之中，准备为将来的请求服务。
内核模块的初始化函数会直接返回。换句话说，模块初始化函数的任务仅仅是为将来模块函数的调用做好准备工作。
模块的退出函数在模块被卸载时被调用。这种编程方式就像事件驱动编程一样，
区别：1、不是所有的应用程序都是事件驱动模式的，而所有的内核模块都是这种方式。
2、应用程序在退出时延迟清理资源或者根本不清理资源，但是内核模块必须谨慎的回收一切资源，
否则的话垃圾数据就会一直存在系统中直到重新启动。
===============================================================================
用户空间和内核空间：

内核模块运行在内核空间，应用程序运行在用户空间，这些是操作系统的基本理论。
运行在不同的级别（CPU内部实现的）
地址映射不同（）
===============================================================================
内核同步：

许多普通的应用程序在执行时都可以不考虑被其他事件打断。
内核代码的运行环境远远没这么简单，就连最基本的内核模块都必须考虑在每一时刻都可能有很多其他系统事件发生。

在内核编程中有以下一些情况需要考虑并发：
Linux支持是多进程的，在同一时刻不同的进程都可以同时访问你的驱动程序。
多数设备都可以对处理器产生中断，中断处理程序被异步的触发执行。当你的驱动要做某些事时可能中断又会被触发。
Linux支持SMP（对称多处理），驱动程序可能同时在不同的CPU核上被执行。
无论如何，Linux内核代码，包括驱动程序，必须是可重入的。可以同时在不同的上下文中执行。

===============================================================================
当前进程：
内核代码可以通过访问全局宏current来访问当前进程，这个宏定义在头文件<asm/current.h>中。
current宏返回一个指向task_struct结构体的指针（该结构体定义在linux/sched.h中）。
current宏返回的这个指针指向当前正在执行的进程，也就是调用open、read这些系统调用的那个进程。
内核代码可以通过current来访问进程的一些特定的属性。

其他的一些细节：
内核的栈很小，比如一页4096字节，所以不要定义太大的自动变量（局部变量等），较大的结构体应该在运行的时候动态的为它们分配空间。
在内核代码中不能执行浮点运算。
===============================================================================
编译和加载：
编译：
$(make) -C $(kernel_dir) M=$(shell pwd) modules
加载和卸载模块：
insmod：功能类似于ld，将模块中所有的未定义的符号链接到内核的符号表？不修改内核模块的磁盘文件，但是可以修改它在内存中的拷贝。
可以传递参数。
内核对insmod的支持：
kernel/module.c中定义的函数 sys_init_module（调用vmalloc） 可以为模块在内核空间中分配存储空间。
然后经内核符号表决义模块中对内核的引用，调用模块的初始化函数。

modprobe：像insmod，可以加载模块到内核，不同的是它会去检查模块中是否引用了当前内核没有定义的符号。
如果找到了这样的未定义符号，它会在模块查找路径中搜索这些符号，如果在其他模块中找到，它会将找到的模块一起加载，
而insmod只是在系统日志文件中报错（符号未定义）。

rmmod：从内核中移除模块。如果模块还在使用的话移除会失败（比如，一个程序整打开这个模块关联的设备）。

lsmod：打印当前被加载到内核的模块
===============================================================================
版本依赖：
内核模块的编译严重依赖与内核的版本。细微的版本差异都会导致模块无法加载。所以要支持多版本时可以使用#ifdef等条件编译

linux/version.h头文件中定义了一些版本相关的宏，被linux/module.h包含。
LINUX_VERSION_CODE 当前版本号，整数
KERNEL_VERSION(major,minor,release) 通过主版本号，次版本号和发行号来计算版本号

kernel symbol table ：内核的符号表，包含所有全局项（函数和变量）的地址。
当一个模块导出一个符号的时候，这个符号会加入到内核符号表，导出的符号可以被其他模块使用。

EXPORT_SYMBOL(name);
EXPORT_SYMBOL_GPL(name); 只对使用GPL许可的可见
通过这些宏来导出符号，这些宏使符号在模块外可见。这些宏必须在模块文件中的全局位置使用，不能放在函数中。

===============================================================================
The kernel is unique environment,内核运行在单一环境中。

模块中可以包含的：
#include <linux/module.h> 重要，符号函数等定义
#include <linux/init.h> 初始化函数。。。

MODULE_LICENSE("GPL"); 许可
MODULE_AUTHOR 作者
MODULE_DESCRIPTION
 MODULE_VERSION
MODULE_ALIAS 别名
MODULE_DEVICE_TABLE
===============================================================================
错误处理：
在出错后必须注销一切已经注册的资源。内核不会记录每个模块已经注册哪些资源，所以必须自己实现清理。


===============================================================================
模块参数：
通过参数执行不同的操作，可以通过insmod，modprobe传递参数。
同时在模块中必须使用module_param宏来申明要使用的参数。该宏定义在moduleparam.h中。
module_param宏接收3个参数，module_param(name,type,perm);
name：名称，模块内定义的变量名。也是insmod等命令行中的参数名称。
type：类型，支持bool invbool charp int long short uint ulong ushort
perm：许可位，参考linux/stat.h中的宏，定义谁可以访问这些参数

module_param_array(name,type,num,perm); 定义数组类型的参数

===============================================================================
在用户层写驱动：
优势：
1、可以链接所有的C库
2、调试
...


===============================================================================
