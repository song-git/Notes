CHAPTER6 字符设备高级操作：

===============================================================================
ioctl：
除了读与写这样的数据传输操作以外，驱动程序还可以提供其他各种对硬件的控制。
用户层ioctl调用如下：int ioctl(int fd, unsigned long cmd, ...);
这个函数是一个独特的系统调用，因为它原型中的第三个参数是... ，通常这个符号是用来表示可变参数。
但其实系统调用是不能使用可变参数的。系统调用必须明确的被定义。
因此这个函数原型中的...不是指任意个数的参数，而是指参数的类型不定。通常是char*类型。
这个符号用在这里只是为了防止编译时的类型检查。而这个参数的实际类型依赖与具体的命令。

每一个ioctl的命令其实算是一个单独的系统调用。不容易实现同一风格和行为的ioctl，不同平台可能会影响它的实现。

驱动中的ioctl与用户层的函数原型不一样，它被如下定义：
int (*ioctl) (struct inode *inode, struct file *filp,unsigned int cmd, unsigned long arg);
前两个参数与open的一样，代表正在操作的文件，cmd参数与用户层一致，可变类型的参数被unsigned long代替。
注意arg参数无法进行类型检查。所以如果用户没有传递它的话，它的值是不确定的。

可以想像，ioctl的实现就是一个庞大的switch语句，用来判断用户传递的是什么命令，然后根据命令执行不同的操作。
这些不同的操作命令是一些不同的整数值，通常定义成宏以方便使用。
这些定义一般放在驱动的头文件中，要使用它们的用户程序可以包含这些头文件。
===============================================================================
命令值的选择：

一般来说，程序员容易使用一些从0或者1开始的整数来作为命令的值。
但是出于安全等考虑，最好使用系统唯一的一个整数值来表示一个命令，以免发生混淆
（在一个驱动中如果遇到它不包含的命令则返回EINVAL错误）。

为了帮助程序员创建一个唯一的命令值，组成这个值的二进制位被划分成几个不同的部分。
最初的Linux内核使用16位的数来表示命令，它的高8位是一个魔数，低8位是每种设备特有的一个值。

include/asm/ioctl.h and Documentation/ioctl-number.txt.

一个命令号的bit位可以分成4部分，type、number、direction、size
asm/ioctl.h 头文件中定义了一些列的宏来帮助获取命令号。这个头文件也被Linux/ioctl.h所包含。
_IO(type,nr); 定义一个命令号，这个命令不需要参数。
_IOR(type,nr,datatype); 这个命令需要从驱动读数据
_IOW(type,nr,datatype); 需要给驱动传入数据
_IOWR(type,nr,datatype); 需要进行双向传输

另外还有一组用来进行反向解码的宏，_IOC_DIR(nr), _IOC_TYPE(nr), _IOC_NR(nr), and _IOC_SIZE(nr) 。
使用它们可以通过命令号得到相应字段的值。

type及nr会被当作参数传递，而datatype会用于sizeof计算长度，详细内容参考头文件asm/ioctl.h

驱动的ioctl函数的参数可以传递一个具体的数值或者一个指针，但一般应该以指针来传递数据。
同样，返回值也可以返回一个整型的状态值或者一个指针。返回值为负的话表示失败。

===============================================================================
返回值：

当一个ioctl遇到一个它不支持的命令时应该返回什么呢？
一些内核函数返回 -EINVAL（无效的值）。
POSIX标准则规定如果一个ioctl的命令无效，则应返回-ENOTTY（对设备无效的ioctl操作），这种形式更适合。

===============================================================================
预定义的命令：

内核会识别一些ioctl的命令，如果驱动中定义的命令与这些命令中的某一个值相同，则驱动中的响应功能永远不会得到调用。
因为系统会优先处理这些它已经识别的命令。
这些预定义好的命令分为三种：
1、任何文件通用的（普通文件、设备文件、FIFO、socket）
2、只适用于普通文件的。
3、文件系统专用的一些命令。

第三类命令的执行依赖于具体文件系统的实现（chattr之类的函数就是靠这些方式实现的）。
而驱动程序一般只关心第一类命令。它们的魔数是'T'。
预定义的适用于任何文件（包含设备文件）的ioctl命令，及第一类有以下一些：
FIOCLEX：File IOctl CLose on EXec，设置这个标志（使用这个命令）将使得进程在执行一个新程序时关闭打开的文件。
FIONCLEX：File IOctl Not CLos on EXec，解除上面命令的设置。
FIOASYNC：设置或重设文件的异步通知，已不使用。
FIOQSIZE：这个命令返回文件或者目录的大小，如果用在设备文件的话，它会返回一个ENOTTY错误。
FIONBIO：File IOctl Non-Blocking I/O，这个命令将会改变文件（filp->f_flags）的O_NONBLOCK的值，
第三个参数将用来设置该值被设置或者取消。
通常也使用fcntl系统调用的 F_SETFL命令来修改这个值。fcntl与ioctl类似，它们被区分主要是历史的原因了。

===============================================================================
如何使用ioctl额外的参数（用户层调用的第三个参数）：

若这个参数是一个整型的话，则它可以被直接使用，如果它是一个指针的话，则在使用过程中需要注意。
如果指针指向一个用户层空间的地址，我们必须得保证这个地址是合法的。使用用户传递的非法地址将会引起灾难。
所以驱动有职责对用户空间的地址做适当的检查，如果这是一个无效的地址则应该返回错误。

copy_from_user和copy_to_user这两个函数可以安全的从用户空间拷贝或者将数据拷贝到用户空间。
这些函数可以很好的在ioctl中工作，但是ioctl通常包含一些很小量的数据，小量的数据使用其他的方法来操作将更有效率。
由此，内核提供access_ok函数来检查地址的合法性，它被定义在头文件asm/uaccess.h中。
int access_ok(int type, const void *addr, unsigned long size);
第一个参数的值可以是 VERIFY_READ 或者 VERIFY_WRITE。取决于是对用户空间进行读还是写。
如果既要读也要写，则使用VERIFY_WRITE，因为它其实是 VERIFY_READ 的一个超集。
addr参数是一个用户空间的地址。size参数表示这块空间的字节数。

access_ok返回一个布尔值，1表示成功，0表示失败。如果该函数返回0，驱动则应该返回-EFAULT
关于access_ok：对于某个地址，它只是检查进程对其是否有适当的访问权限，并确保它不是指向内核中的某个位置。

除了copy_to_user和copy_from_user外，<asm/uaccess.h>中还定义了几个可以用于操作特定字节长度数据的函数

put_user(datum, ptr)  先使用access检查内存是否可用，然后再调用了__put_user
__put_user(datum, ptr) 详细参考头文件asm/uaccess.h
传输的数据大小取决于ptr的类型，如果ptr是一个char *，则传送1个字节的数据，其他类似。
get_user(local, ptr)
__get_user(local, ptr)

===============================================================================
Capabilities and Restricted Operations





===============================================================================
The Implementation of the ioctl Commands

example code here



===============================================================================
Device Control Without ioctl




===============================================================================
阻塞式IO



===============================================================================
Introduction to Sleeping



===============================================================================
Simple Sleeping

===============================================================================
Blocking and Nonblocking Operations

===============================================================================
A Blocking I/O Example

===============================================================================
Advanced Sleeping

===============================================================================
poll and select


===============================================================================
Interaction with read and write

===============================================================================
The Underlying Data Structure

===============================================================================
Asynchronous Notification

===============================================================================
The Driver’s Point of View

===============================================================================
Seeking a Device
The llseek Implementation
===============================================================================
Access Control on a Device File

Single-Open Devices
Restricting Access to a Single User at a Time
Blocking open as an Alternative to EBUSY
Cloning the Device on open

===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================
===============================================================================

